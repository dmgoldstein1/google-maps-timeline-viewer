/**
 * Generated by GitHub Copilot (GPT-5)
 * 
 * Service Worker for Google Maps Timeline Viewer
 * Provides offline functionality and caching strategies
 * 
 * Features:
 * - Cache static assets (HTML, JS, CSS from CDN)
 * - Network-first strategy for API calls with timeout fallback
 * - Cache-first strategy for photos with stale-while-revalidate
 * - Offline fallback page
 * - Update notifications
 */

const CACHE_VERSION = 'v1';
const STATIC_CACHE = `timeline-static-${CACHE_VERSION}`;
const API_CACHE = `timeline-api-${CACHE_VERSION}`;
const PHOTO_CACHE = `timeline-photos-${CACHE_VERSION}`;

// Static assets to precache
const STATIC_ASSETS = [
  '/timeline.html',
  '/api-helper.js',
  'https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js',
  'https://cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.5.43/moment-timezone-with-data.min.js'
];

// Install event - precache static assets
self.addEventListener('install', (event) => {
  console.log('[SW] Installing service worker...');
  
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then((cache) => {
        console.log('[SW] Precaching static assets');
        return cache.addAll(STATIC_ASSETS);
      })
      .then(() => {
        console.log('[SW] Service worker installed');
        return self.skipWaiting(); // Activate immediately
      })
      .catch((error) => {
        console.error('[SW] Precache failed:', error);
      })
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('[SW] Activating service worker...');
  
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames
            .filter((name) => {
              // Delete old cache versions
              return name.startsWith('timeline-') && !name.endsWith(`-${CACHE_VERSION}`);
            })
            .map((name) => {
              console.log('[SW] Deleting old cache:', name);
              return caches.delete(name);
            })
        );
      })
      .then(() => {
        console.log('[SW] Service worker activated');
        return self.clients.claim(); // Take control immediately
      })
  );
});

// Fetch event - implement caching strategies
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // Skip non-GET requests
  if (request.method !== 'GET') {
    return;
  }
  
  // Skip prefetch and upload endpoints (always go to network)
  if (url.pathname.includes('/api/prefetch') || url.pathname.includes('/api/upload')) {
    return;
  }
  
  // Photo requests - cache-first with stale-while-revalidate
  if (url.pathname.startsWith('/api/photo/')) {
    event.respondWith(handlePhotoRequest(request));
    return;
  }
  
  // API cache requests - network-first with timeout
  if (url.pathname.startsWith('/api/cache/')) {
    event.respondWith(handleApiRequest(request));
    return;
  }
  
  // Static assets - cache-first
  if (STATIC_ASSETS.some(asset => request.url.includes(asset))) {
    event.respondWith(handleStaticRequest(request));
    return;
  }
  
  // Default - network-first with cache fallback
  event.respondWith(
    fetch(request)
      .catch(() => {
        return caches.match(request)
          .then(response => response || offlineFallback());
      })
  );
});

/**
 * Handle photo requests - cache-first with stale-while-revalidate
 */
async function handlePhotoRequest(request) {
  const cache = await caches.open(PHOTO_CACHE);
  const cached = await cache.match(request);
  
  // Fetch in background to update cache
  const fetchPromise = fetch(request)
    .then((response) => {
      if (response.ok) {
        cache.put(request, response.clone());
      }
      return response;
    })
    .catch((error) => {
      console.error('[SW] Photo fetch failed:', error);
      return null;
    });
  
  // Return cached immediately if available, otherwise wait for fetch
  return cached || fetchPromise;
}

/**
 * Handle API cache requests - network-first with 3s timeout
 */
async function handleApiRequest(request) {
  const cache = await caches.open(API_CACHE);
  
  try {
    // Try network first with timeout
    const response = await fetchWithTimeout(request, 3000);
    
    if (response.ok) {
      // Cache successful responses
      cache.put(request, response.clone());
    }
    
    return response;
    
  } catch (error) {
    console.log('[SW] Network failed, trying cache:', error);
  // Generated by GitHub Copilot (GPT-5)
    // Fallback to cache
    const cached = await cache.match(request);
    
    if (cached) {
      // Add header to indicate stale data
      const headers = new Headers(cached.headers);
      headers.set('X-SW-Cache-Status', 'stale');
      
      return new Response(cached.body, {
        status: cached.status,
        statusText: cached.statusText,
        headers: headers
      });
    }
    
    // No cache available
    return new Response(
      JSON.stringify({
        error: 'Offline and no cached data available',
        place_id: request.url.split('/').pop(),
        display_name: 'Unknown Location (Offline)'
      }),
      {
        status: 503,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
}

/**
 * Handle static asset requests - cache-first
 */
async function handleStaticRequest(request) {
  const cached = await caches.match(request);
  
  if (cached) {
    // Return cached and update in background
    fetch(request)
      .then((response) => {
        if (response.ok) {
          caches.open(STATIC_CACHE)
            .then(cache => cache.put(request, response));
        }
      })
      .catch(() => {}); // Ignore update errors
    
    return cached;
  }
  
  // Not in cache, fetch from network
  const response = await fetch(request);
  
  if (response.ok) {
    const cache = await caches.open(STATIC_CACHE);
    cache.put(request, response.clone());
  }
  
  return response;
}

/**
 * Fetch with timeout
 */
function fetchWithTimeout(request, timeout = 3000) {
  return Promise.race([
    fetch(request),
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Timeout')), timeout)
    )
  ]);
}

/**
 * Offline fallback response
 */
function offlineFallback() {
  return new Response(
    `<!DOCTYPE html>
    <html>
      <head>
        <title>Offline - Timeline Viewer</title>
        <style>
          body {
            font-family: system-ui, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background: #f5f5f5;
          }
          .offline-message {
            text-align: center;
            padding: 2rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
          }
          h1 { color: #333; }
          p { color: #666; }
        </style>
      </head>
      <body>
        <div class="offline-message">
          <h1>You're Offline</h1>
          <p>Please check your internet connection and try again.</p>
          <button onclick="location.reload()">Retry</button>
        </div>
      </body>
    </html>`,
    {
      status: 503,
      headers: { 'Content-Type': 'text/html' }
    }
  );
}

// Listen for messages from clients
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  
  if (event.data && event.data.type === 'CACHE_STATS') {
    getCacheStats().then(stats => {
      event.ports[0].postMessage(stats);
    });
  }
});

/**
 * Get cache statistics
 */
async function getCacheStats() {
  const cacheNames = await caches.keys();
  const stats = {};
  
  for (const name of cacheNames) {
    const cache = await caches.open(name);
    const keys = await cache.keys();
    stats[name] = keys.length;
  }
  
  return stats;
}
