/**
 * Generated by GitHub Copilot using Claude Sonnet 4.5
 * 
 * API helper functions for Google Maps Timeline Viewer
 * Provides functions to interact with the backend API for place caching
 * 
 * This module replaces the client-side placeDetailsCache with API calls
 */

const API_BASE = '/api';

/**
 * Fetch place details from cache API
 * @param {string} placeId - Google Place ID
 * @returns {Promise<Object>} Place details
 */
async function fetchPlaceFromAPI(placeId) {
  const maxRetries = 3;
  let lastError;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(`${API_BASE}/cache/${placeId}`);
      
      if (response.status === 429) {
        // Quota exceeded
        const data = await response.json();
        showQuotaWarning(data);
        return null;
      }
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${await response.text()}`);
      }
      
      const data = await response.json();
      
      // Check for stale cache warning
      if (response.headers.get('X-Cache-Status') === 'stale') {
        const resetTime = response.headers.get('X-Quota-Reset');
        showStaleDataWarning(resetTime);
      }
      
      return data;
      
    } catch (error) {
      lastError = error;
      console.error(`Attempt ${attempt}/${maxRetries} failed:`, error);
      
      if (attempt < maxRetries) {
        // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
  }
  
  console.error('All retry attempts failed:', lastError);
  return {
    place_id: placeId,
    display_name: 'Unknown Location',
    error: lastError.message
  };
}

/**
 * Get photo URL for a place
 * @param {string} placeId - Google Place ID
 * @param {number} size - Photo width in pixels
 * @returns {string} Photo URL
 */
function getPhotoUrl(placeId, size = 400) {
  return `${API_BASE}/photo/${placeId}/${size}`;
}

/**
 * Get responsive picture element HTML for a photo
 * @param {string} placeId - Google Place ID
 * @returns {string} HTML for picture element with WebP and JPEG sources
 */
function getResponsivePhotoHTML(placeId) {
  return `
    <picture>
      <source type="image/webp" srcset="
        ${API_BASE}/photo/${placeId}/150 150w,
        ${API_BASE}/photo/${placeId}/400 400w,
        ${API_BASE}/photo/${placeId}/800 800w,
        ${API_BASE}/photo/${placeId}/1200 1200w
      " sizes="(max-width: 600px) 150px, (max-width: 1200px) 400px, 800px">
      <img src="${API_BASE}/photo/${placeId}/400" 
           alt="Place photo" 
           loading="lazy"
           onerror="this.parentElement.style.display='none'">
    </picture>
  `;
}

/**
 * Upload timeline file
 * @param {File} file - Timeline JSON file
 * @param {Function} progressCallback - Progress callback (percent)
 * @returns {Promise<Object>} Upload result
 */
async function uploadTimelineFile(file, progressCallback) {
  const formData = new FormData();
  formData.append('timeline', file);
  
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    
    xhr.upload.addEventListener('progress', (e) => {
      if (e.lengthComputable) {
        const percent = (e.loaded / e.total) * 100;
        progressCallback(percent);
      }
    });
    
    xhr.addEventListener('load', () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        resolve(JSON.parse(xhr.responseText));
      } else {
        reject(new Error(`Upload failed: ${xhr.status}`));
      }
    });
    
    xhr.addEventListener('error', () => {
      reject(new Error('Upload failed'));
    });
    
    xhr.open('POST', `${API_BASE}/upload`);
    xhr.send(formData);
  });
}

/**
 * Get list of timeline files
 * @returns {Promise<Array>} Timeline files
 */
async function getTimelineFiles() {
  const response = await fetch(`${API_BASE}/timeline/list`);
  if (!response.ok) throw new Error('Failed to fetch timeline files');
  return await response.json();
}

/**
 * Set active timeline file
 * @param {number} id - Timeline file ID
 * @returns {Promise<Object>} Result
 */
async function setActiveTimeline(id) {
  const response = await fetch(`${API_BASE}/timeline/select`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ id })
  });
  
  if (!response.ok) throw new Error('Failed to set active timeline');
  return await response.json();
}

/**
 * Start prefetch operation
 * @param {Array<string>} placeIds - Place IDs to prefetch
 * @returns {Promise<Object>} Prefetch status
 */
async function startPrefetch(placeIds) {
  const response = await fetch(`${API_BASE}/prefetch`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ placeIds })
  });
  
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error || 'Prefetch failed');
  }
  
  return await response.json();
}

/**
 * Subscribe to prefetch progress updates
 * @param {Function} callback - Called with progress updates
 * @returns {EventSource} EventSource instance
 */
function subscribePrefetchProgress(callback) {
  const eventSource = new EventSource(`${API_BASE}/prefetch/progress`);
  
  eventSource.onmessage = (event) => {
    const progress = JSON.parse(event.data);
    callback(progress);
  };
  
  eventSource.onerror = (error) => {
    console.error('Prefetch progress error:', error);
    eventSource.close();
  };
  
  return eventSource;
}

/**
 * Get cache and API statistics
 * @returns {Promise<Object>} Statistics
 */
async function getStats() {
  const response = await fetch(`${API_BASE}/stats`);
  if (!response.ok) throw new Error('Failed to fetch stats');
  return await response.json();
}

/**
 * Show quota exceeded warning banner
 * @param {Object} data - Quota data
 */
function showQuotaWarning(data) {
  const banner = document.getElementById('quota-warning-banner');
  if (!banner) {
    const newBanner = document.createElement('div');
    newBanner.id = 'quota-warning-banner';
    newBanner.className = 'warning-banner';
    newBanner.innerHTML = `
      <strong>API Quota Exceeded</strong><br>
      Daily limit of ${data.quotaLimit} requests reached.
      Quota resets at midnight. Showing cached data where available.
    `;
    document.body.insertBefore(newBanner, document.body.firstChild);
  }
  banner.style.display = 'block';
}

/**
 * Show stale data warning
 * @param {string} resetTime - ISO timestamp when quota resets
 */
function showStaleDataWarning(resetTime) {
  const banner = document.getElementById('stale-data-banner');
  const resetDate = new Date(resetTime);
  const hoursUntilReset = Math.ceil((resetDate - new Date()) / (1000 * 60 * 60));
  
  if (!banner) {
    const newBanner = document.createElement('div');
    newBanner.id = 'stale-data-banner';
    newBanner.className = 'warning-banner stale';
    newBanner.innerHTML = `
      <strong>Using Cached Data</strong><br>
      API quota exceeded. Showing cached place information.
      Fresh data available in ~${hoursUntilReset} hours.
    `;
    document.body.insertBefore(newBanner, document.body.firstChild);
  }
}
