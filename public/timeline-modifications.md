# Timeline.html Modification Guide

**Generated by GitHub Copilot using Claude Sonnet 4.5**

This document describes the modifications needed to integrate timeline.html with the API backend.

## Summary of Changes

1. **Add API helper script** - Include api-helper.js
2. **Register Service Worker** - Enable offline functionality
3. **Remove client-side cache** - Delete placeDetailsCache and file save/load
4. **Update fetchPlaceDetails** - Call API instead of Google Places directly
5. **Update fetchPhotoForInfoWindow** - Use photo endpoints
6. **Add timeline management UI** - File upload, selector, prefetch modal
7. **Remove IndexedDB for cache** - Keep only for directory handle
8. **Add quota warning banners** - Show API limit warnings

## Detailed Modifications

### 1. HEAD Section (after line 48)

**Add after moment-timezone script:**
```html
<!-- API Helper for backend integration -->
<script src="/api-helper.js"></script>
```

### 2. CSS Section (add warning banner styles ~line 700)

**Add before closing `</style>`:**
```css
/* Warning Banners */
.warning-banner {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 9999;
    background: #ffc107;
    color: #000;
    padding: 12px 20px;
    text-align: center;
    display: none;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.warning-banner.stale {
    background: #17a2b8;
    color: #fff;
}

/* Timeline Controls */
.timeline-controls {
    padding: 10px;
    background: #f8f9fa;
    border-bottom: 1px solid #dee2e6;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.timeline-controls select,
.timeline-controls button {
    padding: 6px 12px;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    background: white;
    cursor: pointer;
}

.timeline-controls button:hover {
    background: #e9ecef;
}

/* Prefetch Modal */
#prefetch-modal {
    display: none;
    position: fixed;
    z-index: 10000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
}

.prefetch-modal-content {
    background: white;
    margin: 10% auto;
    padding: 30px;
    width: 90%;
    max-width: 500px;
    border-radius: 8px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.3);
}

.prefetch-progress {
    width: 100%;
    height: 30px;
    background: #e9ecef;
    border-radius: 4px;
    overflow: hidden;
    margin: 20px 0;
}

.prefetch-progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #007bff, #0056b3);
    transition: width 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
}

.prefetch-status {
    text-align: center;
    color: #666;
    margin-top: 10px;
}

.modal-buttons {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
    margin-top: 20px;
}

.modal-buttons button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
}

.modal-buttons .btn-primary {
    background: #007bff;
    color: white;
}

.modal-buttons .btn-secondary {
    background: #6c757d;
    color: white;
}

.modal-buttons button:hover {
    opacity: 0.9;
}
```

### 3. HTML Body (add before sidebar, ~line 1405)

**Add warning banners and prefetch modal:**
```html
<!-- Warning Banners -->
<div id="quota-warning-banner" class="warning-banner"></div>
<div id="stale-data-banner" class="warning-banner stale"></div>

<!-- Prefetch Modal -->
<div id="prefetch-modal">
    <div class="prefetch-modal-content">
        <h2>Prefetching Place Data</h2>
        <p id="prefetch-message">Downloading place details and photos...</p>
        <div class="prefetch-progress">
            <div id="prefetch-progress-bar" class="prefetch-progress-bar" style="width: 0%">0%</div>
        </div>
        <div id="prefetch-status" class="prefetch-status">
            <div>Processed: <span id="prefetch-processed">0</span> / <span id="prefetch-total">0</span></div>
            <div>Success: <span id="prefetch-success">0</span> | Failed: <span id="prefetch-failed">0</span></div>
            <div id="prefetch-current-place"></div>
        </div>
        <div class="modal-buttons">
            <button id="prefetch-close-btn" class="btn-secondary" disabled>Close</button>
        </div>
    </div>
</div>
```

### 4. Sidebar (add timeline controls, after `#sidebar` opening ~line 1413)

**Add timeline file selector:**
```html
<div class="timeline-controls">
    <select id="timeline-selector" disabled>
        <option value="">Select Timeline...</option>
    </select>
    <button id="upload-timeline-btn" title="Upload Timeline File">ðŸ“¤ Upload</button>
    <button id="prefetch-btn" title="Prefetch All Places" disabled>â¬‡ Prefetch</button>
</div>
<input type="file" id="timeline-file-input" accept=".json" style="display: none;">
```

### 5. Global Variables (replace cache variables ~line 1449)

**Replace:**
```javascript
let placeDetailsCache = {}; // Cache for storing Place Details results
let initialCacheSizeFromFile = 0;
```

**With:**
```javascript
// API integration - cache is server-side
let selectedTimelineId = null; // Active timeline file ID
```

### 6. Service Worker Registration (add to initMap function ~line 1480)

**Add after map initialization:**
```javascript
// Register Service Worker for offline functionality
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js')
        .then(reg => {
            console.log('Service Worker registered:', reg);
            
            // Listen for updates
            reg.addEventListener('updatefound', () => {
                const newWorker = reg.installing;
                newWorker.addEventListener('statechange', () => {
                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                        // New version available
                        if (confirm('New version available! Reload to update?')) {
                            window.location.reload();
                        }
                    }
                });
            });
        })
        .catch(err => console.error('Service Worker registration failed:', err));
}
```

### 7. Replace fetchPlaceDetails function (~line 2183)

**Replace entire function with:**
```javascript
// Fetches place details from API cache
async function fetchPlaceDetails(placeId, fallbackName, placeVisit, index, sidebarItem = null) {
    if (apiCallsDisabled) {
        console.log("API calls disabled. Skipping fetchPlaceDetails, rendering basic marker.");
        const lat = placeVisit.location.latitudeE7 / 1e7;
        const lng = placeVisit.location.longitudeE7 / 1e7;
        renderBasicMarker(lat, lng, fallbackName, placeVisit, index);
        updateSidebarItem(index, fallbackName, null, []);
        return;
    }

    try {
        // Fetch from API
        const placeData = await fetchPlaceFromAPI(placeId);
        
        if (!placeData || placeData.error) {
            throw new Error(placeData?.error || 'Failed to fetch place');
        }
        
        // Convert API response to Place-like object
        const place = {
            id: placeData.place_id,
            displayName: placeData.display_name,
            formattedAddress: placeData.formatted_address,
            location: {
                lat: () => placeData.latitude,
                lng: () => placeData.longitude
            },
            svgIconMaskURI: placeData.icon_mask_uri,
            iconBackgroundColor: placeData.icon_bg_color,
            googleMapsURI: placeData.google_maps_uri,
            types: placeData.types || []
        };
        
        renderPlaceDetails(place, placeVisit, index, sidebarItem);

    } catch (error) {
        console.warn(`Error fetching place details for placeId ${placeId}:`, error);
        // Fallback to basic marker
        const lat = placeVisit.location.latitudeE7 / 1e7;
        const lng = placeVisit.location.longitudeE7 / 1e7;
        renderBasicMarker(lat, lng, fallbackName, placeVisit, index);
        
        if (sidebarItem) {
            const nametag = sidebarItem.querySelector('strong');
            if (nametag) nametag.textContent = fallbackName;
        } else {
            updateSidebarItem(index, fallbackName, null, []);
        }
    }
}
```

### 8. Replace fetchPhotoForInfoWindow function (~line 2477)

**Replace entire function with:**
```javascript
// Fetches photo for InfoWindow using API endpoint
async function fetchPhotoForInfoWindow(infoWindow) {
    if (apiCallsDisabled) {
        console.log("API calls disabled. Skipping photo fetch.");
        if (infoWindow && !infoWindow.photoFetched) {
            try {
                const contentNode = document.createElement('div');
                contentNode.innerHTML = infoWindow.getContent();
                const photoContainer = contentNode.querySelector(`.photo-container`);
                if (photoContainer) {
                    photoContainer.innerHTML = '<div class="photo-placeholder">Photos disabled</div>';
                    infoWindow.setContent(contentNode.innerHTML);
                }
                infoWindow.photoFetched = true;
            } catch (e) { console.error("Error updating infowindow content when API disabled:", e); }
        }
        return;
    }

    if (!infoWindow || !infoWindow.placeId || infoWindow.photoFetched) {
        console.log(`Skipping photo fetch for placeId: ${infoWindow?.placeId}`);
        if (infoWindow && !infoWindow.placeId && !infoWindow.photoFetched) {
            try {
                const contentNode = document.createElement('div');
                contentNode.innerHTML = infoWindow.getContent();
                const photoContainer = contentNode.querySelector(`.photo-container`);
                if (photoContainer) {
                    photoContainer.innerHTML = '<div class="photo-placeholder">No photo available</div>';
                    infoWindow.setContent(contentNode.innerHTML);
                }
                infoWindow.photoFetched = true;
            } catch (e) { console.error("Error updating basic marker infowindow content:", e); }
        }
        return;
    }
    
    console.log(`Loading photo for placeId: ${infoWindow.placeId}`);
    
    try {
        const contentNode = document.createElement('div');
        contentNode.innerHTML = infoWindow.getContent();
        const photoContainer = contentNode.querySelector(`.photo-container`);
        
        if (photoContainer) {
            // Use responsive picture element
            photoContainer.innerHTML = getResponsivePhotoHTML(infoWindow.placeId);
            infoWindow.setContent(contentNode.innerHTML);
        }
        
        infoWindow.photoFetched = true;
        
    } catch (error) {
        console.error(`Error loading photo for placeId ${infoWindow.placeId}:`, error);
        // Show placeholder on error
        try {
            const contentNode = document.createElement('div');
            contentNode.innerHTML = infoWindow.getContent();
            const photoContainer = contentNode.querySelector(`.photo-container`);
            if (photoContainer) {
                photoContainer.innerHTML = '<div class="photo-placeholder">Photo unavailable</div>';
                infoWindow.setContent(contentNode.innerHTML);
            }
            infoWindow.photoFetched = true;
        } catch (e) { console.error("Error setting photo placeholder:", e); }
    }
}
```

### 9. Remove cache file functions (delete ~lines 4046-4070)

**Delete saveCacheBtn event listener and entire initCacheControls function**

### 10. Remove cache loading from file picker (modify ~line 4177-4200)

**Remove TimelinePlaceCache.json loading logic** - Delete the entire section that loads placeCacheFile

### 11. Remove IndexedDB cache storage (keep only directory handle, ~line 4715)

**Keep the IndexedDB functions but remove any cache storage** - Only use for directory handle persistence

### 12. Add Timeline Management Functions (add before initCacheControls ~line 4030)

**Add new initialization function:**
```javascript
async function initTimelineManagement() {
    const selector = document.getElementById('timeline-selector');
    const uploadBtn = document.getElementById('upload-timeline-btn');
    const fileInput = document.getElementById('timeline-file-input');
    const prefetchBtn = document.getElementById('prefetch-btn');
    
    // Load timeline files
    async function loadTimelineList() {
        try {
            const files = await getTimelineFiles();
            selector.innerHTML = '<option value="">Select Timeline...</option>';
            
            files.forEach(file => {
                const option = document.createElement('option');
                option.value = file.id;
                option.textContent = `${file.filename} (${file.place_count} places)`;
                if (file.is_active) option.selected = true;
                selector.appendChild(option);
            });
            
            selector.disabled = false;
            
            // Enable prefetch if timeline selected
            const activeFile = files.find(f => f.is_active);
            if (activeFile) {
                selectedTimelineId = activeFile.id;
                prefetchBtn.disabled = false;
            }
            
        } catch (error) {
            console.error('Failed to load timeline files:', error);
        }
    }
    
    // Handle timeline selection
    selector.addEventListener('change', async (e) => {
        const id = parseInt(e.target.value);
        if (!id) return;
        
        try {
            await setActiveTimeline(id);
            selectedTimelineId = id;
            prefetchBtn.disabled = false;
            alert('Timeline activated. Click "Go" to reload the view.');
        } catch (error) {
            console.error('Failed to set active timeline:', error);
            alert('Failed to activate timeline. See console.');
        }
    });
    
    // Handle file upload
    uploadBtn.addEventListener('click', () => {
        fileInput.click();
    });
    
    fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const progressBar = document.createElement('div');
        progressBar.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 16px rgba(0,0,0,0.3); z-index: 10000;';
        progressBar.innerHTML = '<div>Uploading: <span id="upload-percent">0%</span></div>';
        document.body.appendChild(progressBar);
        
        try {
            const result = await uploadTimelineFile(file, (percent) => {
                document.getElementById('upload-percent').textContent = `${Math.round(percent)}%`;
            });
            
            document.body.removeChild(progressBar);
            alert(`Upload complete! Detected format: ${result.format}\nPlaces found: ${result.placeCount}`);
            await loadTimelineList();
            
        } catch (error) {
            document.body.removeChild(progressBar);
            console.error('Upload failed:', error);
            alert('Upload failed. See console.');
        }
        
        fileInput.value = ''; // Reset input
    });
    
    // Handle prefetch
    prefetchBtn.addEventListener('click', showPrefetchModal);
    
    // Initialize
    await loadTimelineList();
}

function showPrefetchModal() {
    const modal = document.getElementById('prefetch-modal');
    const progressBar = document.getElementById('prefetch-progress-bar');
    const closeBtn = document.getElementById('prefetch-close-btn');
    const processedSpan = document.getElementById('prefetch-processed');
    const totalSpan = document.getElementById('prefetch-total');
    const successSpan = document.getElementById('prefetch-success');
    const failedSpan = document.getElementById('prefetch-failed');
    const currentPlace = document.getElementById('prefetch-current-place');
    
    modal.style.display = 'block';
    closeBtn.disabled = true;
    
    // Subscribe to progress
    const eventSource = subscribePrefetchProgress((progress) => {
        const percent = (progress.processed / progress.total * 100).toFixed(1);
        progressBar.style.width = `${percent}%`;
        progressBar.textContent = `${percent}%`;
        
        processedSpan.textContent = progress.processed;
        totalSpan.textContent = progress.total;
        successSpan.textContent = progress.success;
        failedSpan.textContent = progress.failed;
        currentPlace.textContent = progress.currentPlaceId ? `Fetching: ${progress.currentPlaceId}` : '';
        
        if (progress.status === 'completed') {
            closeBtn.disabled = false;
            currentPlace.textContent = 'âœ“ Complete!';
            eventSource.close();
        } else if (progress.status === 'failed') {
            closeBtn.disabled = false;
            currentPlace.textContent = 'âœ— Failed';
            eventSource.close();
        }
    });
    
    // Start prefetch
    startPrefetch([]) // Empty array means all places from active timeline
        .catch(error => {
            console.error('Prefetch failed:', error);
            alert('Prefetch failed to start. See console.');
            modal.style.display = 'none';
            eventSource.close();
        });
    
    closeBtn.onclick = () => {
        modal.style.display = 'none';
        eventSource.close();
    };
}
```

### 13. Update initialization (~line 5240)

**Add to initMap or window.onload:**
```javascript
// Initialize timeline management
initTimelineManagement();
```

### 14. Remove incrementApiCallCount calls

**Search for `incrementApiCallCount()` and remove all occurrences** - API tracking is now server-side

### 15. Update updateCacheIndicator function (~line 2100)

**Replace with server stats:**
```javascript
async function updateCacheIndicator() {
    try {
        const stats = await getStats();
        const cacheSize = stats.places || 0;
        const quotaUsed = stats.apiUsage?.today || 0;
        const quotaLimit = 5000; // Daily limit
        
        const indicator = document.getElementById('cacheIndicator');
        if (indicator) {
            indicator.textContent = `Cache: ${cacheSize} places | API: ${quotaUsed}/${quotaLimit} today`;
        }
    } catch (error) {
        console.error('Failed to update cache indicator:', error);
    }
}

// Call periodically
setInterval(updateCacheIndicator, 30000); // Every 30 seconds
```

## Testing Checklist

- [ ] Service Worker registers successfully
- [ ] Timeline file upload works
- [ ] Timeline selector populates
- [ ] Place details load from API
- [ ] Photos display with responsive images
- [ ] Prefetch modal shows progress
- [ ] Quota warnings appear when limit reached
- [ ] Offline mode works with cached data
- [ ] Map markers render correctly
- [ ] Info windows show photos
