# API Documentation

**Generated by GitHub Copilot using Claude Sonnet 4.5**

This document describes the REST API endpoints for the Google Maps Timeline Viewer backend.

## Base URL

```
http://localhost:3000/api
```

## Endpoints

### Place Cache

#### GET /api/cache/:placeId

Retrieve cached place details. Will fetch from Google Places API if not cached and quota permits.

**Parameters:**
- `placeId` (path) - Google Place ID

**Response:**
```json
{
  "place_id": "ChIJ...",
  "display_name": "Eiffel Tower",
  "formatted_address": "Champ de Mars, Paris, France",
  "latitude": 48.8584,
  "longitude": 2.2945,
  "icon_mask_uri": "https://maps.gstatic.com/mapfiles/...",
  "icon_bg_color": "#4CAF50",
  "google_maps_uri": "https://maps.google.com/?cid=...",
  "types": ["tourist_attraction", "point_of_interest"],
  "cached_at": "2025-01-15T10:30:00.000Z"
}
```

**Headers:**
- `X-Cache-Status`: `fresh` | `stale` (if quota exceeded)
- `X-Quota-Reset`: ISO 8601 timestamp when quota resets

**Status Codes:**
- `200` - Success
- `429` - Quota exceeded (returns cached data if available)
- `503` - Service unavailable

---

### Photos

#### GET /api/photo/:placeId/:size

Retrieve photo for a place at specified size. Automatically generates WebP and JPEG versions.

**Parameters:**
- `placeId` (path) - Google Place ID
- `size` (path) - Width in pixels: `150` | `400` | `800` | `1200`

**Query Parameters:**
- `format` (optional) - Force format: `webp` | `jpeg` (default: auto-detect from Accept header)

**Headers:**
- `Accept: image/webp` - Prefer WebP format (Chrome, Edge, Firefox)
- `Accept: image/*` - Fallback to JPEG

**Response:**
- Image binary data
- Content-Type: `image/webp` or `image/jpeg`
- Cache-Control: `public, max-age=31536000` (1 year)

**Status Codes:**
- `200` - Success
- `404` - Photo not found
- `500` - Image processing error

---

### Timeline Management

#### POST /api/upload

Upload and parse timeline JSON file. Auto-detects format (iOS, Google Takeout, Semantic Segments).

**Request:**
- Content-Type: `multipart/form-data`
- Field name: `timeline`
- File: Timeline.json

**Response:**
```json
{
  "id": 1,
  "filename": "Timeline.json",
  "format": "ios_timeline",
  "placeCount": 1523,
  "dateRange": {
    "start": "2020-01-01",
    "end": "2025-01-15"
  },
  "uploadedAt": "2025-01-15T12:00:00.000Z"
}
```

**Status Codes:**
- `200` - Success
- `400` - Invalid file or format
- `500` - Upload failed

---

#### GET /api/timeline/list

List all uploaded timeline files.

**Response:**
```json
[
  {
    "id": 1,
    "filename": "Timeline.json",
    "format": "ios_timeline",
    "place_count": 1523,
    "is_active": true,
    "uploaded_at": "2025-01-15T12:00:00.000Z"
  }
]
```

---

#### POST /api/timeline/select

Set active timeline file for viewing.

**Request:**
```json
{
  "id": 1
}
```

**Response:**
```json
{
  "success": true,
  "message": "Timeline activated"
}
```

**Status Codes:**
- `200` - Success
- `404` - Timeline not found

---

### Prefetch

#### POST /api/prefetch

Start background prefetch of place details and photos.

**Request:**
```json
{
  "placeIds": ["ChIJ...", "ChIJ..."]  // Empty array = all places from active timeline
}
```

**Response:**
```json
{
  "jobId": "prefetch-1737028800000",
  "totalPlaces": 1523,
  "status": "started"
}
```

**Status Codes:**
- `200` - Job started
- `400` - Invalid request
- `429` - Quota exhausted

---

#### GET /api/prefetch/progress

Subscribe to Server-Sent Events for real-time prefetch progress.

**Response:** (stream)
```
event: progress
data: {"processed":50,"total":1523,"success":48,"failed":2,"status":"running","currentPlaceId":"ChIJ..."}

event: progress
data: {"processed":1523,"total":1523,"success":1521,"failed":2,"status":"completed"}
```

**Fields:**
- `processed` - Number of places processed
- `total` - Total places to process
- `success` - Successfully cached
- `failed` - Failed to cache
- `status` - `idle` | `running` | `completed` | `failed`
- `currentPlaceId` - Currently processing place

---

### Statistics

#### GET /api/stats

Get cache and API usage statistics.

**Response:**
```json
{
  "places": 1523,
  "photos": 1200,
  "apiUsage": {
    "today": 450,
    "limit": 5000,
    "resetAt": "2025-01-16T00:00:00.000Z"
  },
  "cache": {
    "size": "2.3 GB",
    "oldestEntry": "2025-01-01T00:00:00.000Z",
    "newestEntry": "2025-01-15T12:00:00.000Z"
  }
}
```

---

## Rate Limiting

The API implements rate limiting to stay within Google Places API free tier:

- **Quota:** 5,000 requests per day
- **Rate:** 200ms delay between requests
- **Concurrency:** 5 parallel workers
- **Reset:** Daily at midnight UTC

When quota is exceeded:
- Cached data returned with `X-Cache-Status: stale` header
- New requests return `429 Too Many Requests`
- Quota resets at midnight UTC

---

## Error Responses

All errors follow this format:

```json
{
  "error": "Error message",
  "code": "ERROR_CODE",
  "details": {}
}
```

**Common Error Codes:**
- `QUOTA_EXCEEDED` - Daily API quota reached
- `INVALID_PLACE_ID` - Place ID not found
- `UPLOAD_FAILED` - Timeline upload error
- `FORMAT_UNKNOWN` - Unrecognized timeline format
- `DATABASE_ERROR` - SQLite operation failed

---

## Client Integration

### JavaScript Example

```javascript
// Fetch place details
const place = await fetch('/api/cache/ChIJ...')
  .then(r => r.json());

// Load photo with WebP support
const photoUrl = `/api/photo/${placeId}/400`;
const img = document.createElement('img');
img.src = photoUrl;

// Upload timeline
const formData = new FormData();
formData.append('timeline', fileInput.files[0]);

const result = await fetch('/api/upload', {
  method: 'POST',
  body: formData
}).then(r => r.json());

// Subscribe to prefetch progress
const eventSource = new EventSource('/api/prefetch/progress');
eventSource.onmessage = (event) => {
  const progress = JSON.parse(event.data);
  console.log(`${progress.processed}/${progress.total}`);
};
```

---

## Authentication

Currently, the API does not require authentication. If deploying publicly, add authentication:

1. Use reverse proxy (Nginx, Caddy) with basic auth
2. Implement OAuth2 with Google Sign-In
3. Add API key validation middleware

See [Production Deployment](#production-deployment) for security recommendations.
