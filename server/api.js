/**
 * Generated by GitHub Copilot (GPT-5)
 * 
 * Express API server for Google Maps Timeline Viewer
 * Provides endpoints for place cache, photos, prefetch operations, and timeline management
 * 
 * Endpoints:
 * - GET /api/cache/:placeId - Get cached place details
 * - GET /api/photo/:placeId/:size - Get place photo (WebP/JPEG based on Accept header)
 * - POST /api/prefetch - Start batch prefetch operation
 * - GET /api/prefetch/progress - Server-Sent Events for prefetch progress
 * - POST /api/upload - Upload timeline JSON file
 * - GET /api/timeline/list - List all timeline files
 * - POST /api/timeline/select - Set active timeline file
 * - GET /api/stats - Get cache and API usage statistics
 * - GET /health - Health check endpoint
 */

import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import multer from 'multer';
import { readFile, writeFile } from 'fs/promises';
import { join } from 'path';
import pino from 'pino';
import fetch from 'node-fetch';
import {
  initDatabase,
  getDatabase,
  getCachedPlace,
  setCachedPlace,
  getCachedPhoto,
  setCachedPhoto,
  getTimelineFiles,
  getActiveTimeline,
  addTimelineFile,
  setActiveTimeline,
  getTodayApiUsage,
  incrementApiUsage,
  isQuotaExceeded,
  getAllCachedPlaceIds
} from './db.js';
import { detectFormat, extractPlaceIds, validateTimelineData } from './format-detector.js';
import {
  initPhotosDirectory,
  processPhoto,
  photoExists,
  getPhotoStats,
  getAvailableSizes
} from './image-processor.js';

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  ...(process.env.NODE_ENV !== 'test' ? {
    transport: {
      target: 'pino-pretty',
      options: { colorize: true }
    }
  } : {})
});

const app = express();
// Security hardening
app.disable('x-powered-by');
const PORT = process.env.PORT || 3000;
const DATA_DIR = process.env.DATA_DIR || '/data';
const TIMELINE_DIR = join(DATA_DIR, 'timeline');

// Middleware
app.use(helmet({ crossOriginResourcePolicy: { policy: 'cross-origin' } }));

// CORS allowlist from env (comma-separated origins). Empty = allow same-origin only.
const allowedOrigins = (process.env.ALLOWED_ORIGINS || '')
  .split(',')
  .map(s => s.trim())
  .filter(Boolean);

app.use(cors({
  origin: (origin, cb) => {
    if (!origin) return cb(null, true);
    if (allowedOrigins.length === 0 || allowedOrigins.includes(origin)) return cb(null, true);
    return cb(new Error('Not allowed by CORS'));
  },
  credentials: false
}));

// Body parsers with tighter limits
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: false, limit: '10mb' }));

// Global rate limiting
const windowMs = parseInt(process.env.RATE_LIMIT_WINDOW_MS || '60000');
const maxReq = parseInt(process.env.RATE_LIMIT_MAX || '120');
const apiLimiter = rateLimit({ windowMs, max: maxReq, standardHeaders: true, legacyHeaders: false });
app.use(apiLimiter);

// Request logging
app.use((req, res, next) => {
  logger.info({ method: req.method, url: req.url }, 'Incoming request');
  next();
});

// File upload configuration - use memory storage in test mode to avoid permission issues
let multerStorage;
if (process.env.TEST_MODE === 'true') {
  multerStorage = multer.memoryStorage();
} else {
  multerStorage = multer.diskStorage({ destination: TIMELINE_DIR });
}

const upload = multer({
  storage: multerStorage,
  limits: { fileSize: 25 * 1024 * 1024 },
  fileFilter: (req, file, cb) => {
    const ok = ['application/json','text/json','text/plain','application/octet-stream'];
    if (ok.includes(file.mimetype)) return cb(null, true);
    cb(new Error('Invalid file type'));
  }
});

// Prefetch progress tracking
let prefetchProgress = {
  isRunning: false,
  total: 0,
  completed: 0,
  currentPlace: null,
  errors: [],
  startTime: null,
  estimatedTimeRemaining: null
};

const prefetchClients = new Set();

/**
 * Get Google Maps API key from file or environment
 */
async function getApiKey() {
  const keyFile = process.env.GOOGLE_MAPS_API_KEY_FILE;
  
  if (keyFile) {
    try {
      const key = await readFile(keyFile, 'utf-8');
      return key.trim();
    } catch (error) {
      logger.error({ error: error.message }, 'Failed to read API key from file');
    }
  }
  
  return process.env.GOOGLE_MAPS_API_KEY || '';
}

/**
 * Fetch place details from Google Places API
 */
async function fetchPlaceFromGoogle(placeId) {
  const apiKey = await getApiKey();
  if (!apiKey) {
    throw new Error('Google Maps API key not configured');
  }
  
  const url = `https://places.googleapis.com/v1/places/${placeId}`;
  const fields = [
    'id',
    'displayName',
    'formattedAddress',
    'location',
    'svgIconMaskURI',
    'iconBackgroundColor',
    'googleMapsURI',
    'types',
    'photos'
  ];
  
  const response = await fetch(url, {
    method: 'GET',
    headers: {
      'X-Goog-Api-Key': apiKey,
      'X-Goog-FieldMask': fields.join(',')
    }
  });
  
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Places API error: ${response.status} - ${error}`);
  }
  
  return await response.json();
}

/**
 * Fetch photo from Google Places API
 */
async function fetchPhotoFromGoogle(photoName, maxWidth = 1200) {
  const apiKey = await getApiKey();
  if (!apiKey) {
    throw new Error('Google Maps API key not configured');
  }
  
  const url = `https://places.googleapis.com/v1/${photoName}/media?maxWidthPx=${maxWidth}&key=${apiKey}`;
  
  const response = await fetch(url);
  
  if (!response.ok) {
    throw new Error(`Photo API error: ${response.status}`);
  }
  
  return await response.buffer();
}

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Get cached place details
app.get('/api/cache/:placeId', async (req, res) => {
  try {
    const { placeId } = req.params;
    if (!/^[-_.A-Za-z0-9]+$/.test(placeId)) {
      return res.status(400).json({ error: 'Invalid placeId' });
    }
    const usage = getTodayApiUsage();
    
    // Check cache first
    const cached = getCachedPlace(placeId);
    
    if (cached && !cached.isExpired) {
      logger.debug({ placeId }, 'Serving from cache');
      res.set('X-Cache-Status', 'hit');
      return res.json({
        ...cached,
        fromCache: true
      });
    }
    
    // Check if quota exceeded
    if (isQuotaExceeded()) {
      if (cached) {
        // Return stale cache with warning
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(0, 0, 0, 0);
        
        res.set('X-Cache-Status', 'stale');
        res.set('X-Quota-Reset', tomorrow.toISOString());
        
        return res.json({
          ...cached,
          fromCache: true,
          isStale: true,
          quotaExceeded: true,
          quotaResetTime: tomorrow.toISOString()
        });
      }
      
      return res.status(429).json({
        error: 'API quota exceeded',
        quotaUsed: usage.count,
        quotaLimit: usage.quota_limit,
        message: 'Daily API quota exceeded. Quota resets at midnight.'
      });
    }
    
    // Fetch from Google Places API
    logger.info({ placeId }, 'Fetching from Google Places API');
    const placeData = await fetchPlaceFromGoogle(placeId);
    
    // Increment usage
    incrementApiUsage();
    
    // Cache the result
    const cacheData = {
      displayName: placeData.displayName?.text,
      formattedAddress: placeData.formattedAddress,
      location: placeData.location,
      svgIconMaskURI: placeData.svgIconMaskURI,
      iconBackgroundColor: placeData.iconBackgroundColor,
      googleMapsURI: placeData.googleMapsURI,
      types: placeData.types
    };
    
    setCachedPlace(placeId, cacheData);
    
    // Process photos if available
    if (placeData.photos && placeData.photos.length > 0) {
      try {
        const photoBuffer = await fetchPhotoFromGoogle(placeData.photos[0].name);
        incrementApiUsage(); // Count photo fetch
        
        const photoResult = await processPhoto(photoBuffer, placeId);
        if (photoResult.success) {
          setCachedPhoto(placeId, photoResult.hasWebP, photoResult.hasJPEG, photoResult.sizes);
        }
      } catch (photoError) {
        logger.error({ placeId, error: photoError.message }, 'Failed to fetch/process photo');
      }
    }
    
    res.json({
      ...cacheData,
      place_id: placeId,
      fromCache: false
    });
    
  } catch (error) {
    logger.error({ error: error.message }, 'Error fetching place details');
    res.status(500).json({ error: error.message });
  }
});

// Get place photo
app.get('/api/photo/:placeId/:size', async (req, res) => {
  try {
    const { placeId, size } = req.params;
    const sizeNum = parseInt(size);

    // Basic input validation to mitigate path traversal
    if (!/^[-_.A-Za-z0-9]+$/.test(placeId)) {
      return res.status(400).json({ error: 'Invalid placeId' });
    }
    if (![150, 400, 800, 1200].includes(sizeNum)) {
      return res.status(400).json({ error: 'Invalid size' });
    }
    
    // Check Accept header for format preference
    const acceptsWebP = req.accepts('image/webp');
    const format = acceptsWebP ? 'webp' : 'jpeg';
    
    // Check if photo exists
    const exists = await photoExists(placeId, sizeNum, format);
    
    if (!exists) {
      // Try alternate format
      const altFormat = format === 'webp' ? 'jpeg' : 'webp';
      const altExists = await photoExists(placeId, sizeNum, altFormat);
      
      if (!altExists) {
        return res.status(404).json({ error: 'Photo not found' });
      }
      
      // Serve alternate format
      const photoPath = join(DATA_DIR, 'photos', placeId, `${sizeNum}.${altFormat}`);
      return res.sendFile(photoPath);
    }
    
    const photoPath = join(DATA_DIR, 'photos', placeId, `${sizeNum}.${format}`);
    res.sendFile(photoPath, { dotfiles: 'deny' });
    
  } catch (error) {
    logger.error({ error: error.message }, 'Error serving photo');
    res.status(500).json({ error: error.message });
  }
});

// Upload timeline file
// Stricter rate limit for upload
const uploadLimiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 10, standardHeaders: true, legacyHeaders: false });
app.post('/api/upload', uploadLimiter, upload.single('timeline'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }
    
    // Read and parse file
    if (!req.file.path.startsWith(TIMELINE_DIR)) {
      return res.status(400).json({ error: 'Invalid upload path' });
    }
    // Extra path safety: ensure file resides directly under TIMELINE_DIR
    const resolvedPath = join(TIMELINE_DIR, req.file.filename);
    if (resolvedPath !== req.file.path) {
      return res.status(400).json({ error: 'Invalid file resolution' });
    }
    const content = await readFile(resolvedPath, 'utf-8');
    let data;
    try {
      data = JSON.parse(content);
    } catch (e) {
      return res.status(400).json({ error: 'Invalid JSON' });
    }
    
    // Detect format
    const detection = detectFormat(data);
    
    // Validate
    const validation = validateTimelineData(data);
    
    if (!validation.valid) {
      return res.status(400).json({
        error: 'Invalid timeline data',
        message: validation.message
      });
    }
    
    // Add to database
    const fileId = addTimelineFile(req.file.filename, detection.format, detection.confidence);
    
    // Extract place IDs for prefetch info
    const placeIds = extractPlaceIds(data, detection.format);
    
    res.json({
      success: true,
      fileId,
      filename: req.file.filename,
      format: detection.format,
      confidence: detection.confidence,
      placeCount: placeIds.length,
      message: detection.message,
      requiresConfirmation: detection.confidence < 80
    });
    
  } catch (error) {
    logger.error({ error: error.message }, 'Error uploading timeline file');
    res.status(500).json({ error: error.message });
  }
});

// List timeline files
app.get('/api/timeline/list', async (req, res) => {
  try {
    const files = getTimelineFiles();
    res.json(files);
  } catch (error) {
    logger.error({ error: error.message }, 'Error listing timeline files');
    res.status(500).json({ error: error.message });
  }
});

// Select active timeline
app.post('/api/timeline/select', async (req, res) => {
  try {
    const { id } = req.body;
    
    if (!id) {
      return res.status(400).json({ error: 'Timeline ID required' });
    }
    
    setActiveTimeline(id);
    res.json({ success: true });
    
  } catch (error) {
    logger.error({ error: error.message }, 'Error selecting timeline');
    res.status(500).json({ error: error.message });
  }
});

// Start prefetch operation
app.post('/api/prefetch', async (req, res) => {
  try {
    if (prefetchProgress.isRunning) {
      return res.status(409).json({ error: 'Prefetch already in progress' });
    }
    
    const { placeIds } = req.body;
    
    if (!placeIds || !Array.isArray(placeIds)) {
      return res.status(400).json({ error: 'placeIds array required' });
    }
    
    // Filter out already cached places
    const cachedIds = getAllCachedPlaceIds();
    const uncachedIds = placeIds.filter(id => !cachedIds.includes(id));
    
    prefetchProgress = {
      isRunning: true,
      total: uncachedIds.length,
      completed: 0,
      currentPlace: null,
      errors: [],
      startTime: Date.now(),
      estimatedTimeRemaining: null
    };
    
    // Start prefetch in background
    setImmediate(() => runPrefetch(uncachedIds));
    
    res.json({
      success: true,
      total: uncachedIds.length,
      alreadyCached: placeIds.length - uncachedIds.length
    });
    
  } catch (error) {
    logger.error({ error: error.message }, 'Error starting prefetch');
    res.status(500).json({ error: error.message });
  }
});

// Prefetch progress (Server-Sent Events)
app.get('/api/prefetch/progress', (req, res) => {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  
  // Add client to set
  prefetchClients.add(res);
  
  // Send initial state
  res.write(`data: ${JSON.stringify(prefetchProgress)}\n\n`);
  
  // Remove client on disconnect
  req.on('close', () => {
    prefetchClients.delete(res);
  });
});

// Get statistics
app.get('/api/stats', async (req, res) => {
  try {
    const usage = getTodayApiUsage();
    const photoStats = await getPhotoStats();
    const db = getDatabase();
    
    
    let placesCount = 0;
    let timelinesCount = 0;
    
    if (db) {
      placesCount = db.prepare('SELECT COUNT(*) as count FROM places').get().count;
      timelinesCount = db.prepare('SELECT COUNT(*) as count FROM timeline_files').get().count;
    }
    
    res.json({
      apiUsage: {
        today: usage.count,
        limit: usage.quota_limit,
        remaining: usage.quota_limit - usage.count,
        quotaExceeded: isQuotaExceeded()
      },
      cache: {
        placesCount,
        timelinesCount
      },
      photos: photoStats
    });
    
  } catch (error) {
    logger.error({ error: error.message }, 'Error getting stats');
    res.status(500).json({ error: error.message });
  }
});

/**
 * Run prefetch operation
 */
async function runPrefetch(placeIds) {
  const delayMs = parseInt(process.env.API_REQUEST_DELAY_MS || '200');
  
  for (const placeId of placeIds) {
    if (!prefetchProgress.isRunning) {
      logger.info('Prefetch cancelled');
      break;
    }
    
    try {
      prefetchProgress.currentPlace = placeId;
      
      // Check quota
      if (isQuotaExceeded()) {
        prefetchProgress.errors.push({
          placeId,
          error: 'Quota exceeded'
        });
        logger.warn('Quota exceeded, stopping prefetch');
        break;
      }
      
      // Fetch place
      const placeData = await fetchPlaceFromGoogle(placeId);
      incrementApiUsage();
      
      // Cache place data
      const cacheData = {
        displayName: placeData.displayName?.text,
        formattedAddress: placeData.formattedAddress,
        location: placeData.location,
        svgIconMaskURI: placeData.svgIconMaskURI,
        iconBackgroundColor: placeData.iconBackgroundColor,
        googleMapsURI: placeData.googleMapsURI,
        types: placeData.types
      };
      
      setCachedPlace(placeId, cacheData);
      
      // Fetch and process photo
      if (placeData.photos && placeData.photos.length > 0) {
        try {
          const photoBuffer = await fetchPhotoFromGoogle(placeData.photos[0].name);
          incrementApiUsage();
          
          const photoResult = await processPhoto(photoBuffer, placeId);
          if (photoResult.success) {
            setCachedPhoto(placeId, photoResult.hasWebP, photoResult.hasJPEG, photoResult.sizes);
          }
        } catch (photoError) {
          logger.error({ placeId, error: photoError.message }, 'Photo fetch failed');
        }
      }
      
      prefetchProgress.completed++;
      
      // Calculate ETA
      const elapsed = Date.now() - prefetchProgress.startTime;
      const avgTime = elapsed / prefetchProgress.completed;
      const remaining = prefetchProgress.total - prefetchProgress.completed;
      prefetchProgress.estimatedTimeRemaining = Math.round((avgTime * remaining) / 1000);
      
      // Broadcast progress
      broadcastProgress();
      
      // Rate limiting delay
      await new Promise(resolve => setTimeout(resolve, delayMs));
      
    } catch (error) {
      logger.error({ placeId, error: error.message }, 'Prefetch error');
      prefetchProgress.errors.push({
        placeId,
        error: error.message
      });
      prefetchProgress.completed++;
      broadcastProgress();
    }
  }
  
  prefetchProgress.isRunning = false;
  prefetchProgress.currentPlace = null;
  broadcastProgress();
  
  logger.info(
    {
      total: prefetchProgress.total,
      completed: prefetchProgress.completed,
      errors: prefetchProgress.errors.length
    },
    'Prefetch completed'
  );
}

/**
 * Broadcast progress to all SSE clients
 */
function broadcastProgress() {
  const data = JSON.stringify(prefetchProgress);
  for (const client of prefetchClients) {
    try {
      client.write(`data: ${data}\n\n`);
    } catch (error) {
      prefetchClients.delete(client);
    }
  }
}

// Error handling middleware
app.use((err, req, res, next) => {
  logger.error({ error: err.message, stack: err.stack }, 'Unhandled error');
  res.status(500).json({ error: 'Internal server error' });
});

// Export app and initialization function for testing
export { app, logger };

/**
 * Initialize app (database, photos directory)
 */
export async function initializeApp() {
  try {
    await initDatabase();
  } catch (error) {
    // In test mode, we can continue even if database initialization fails
    if (process.env.TEST_MODE !== 'true') {
      throw error;
    }
    logger.warn({ error: error.message }, 'Database initialization failed (continuing in test mode)');
  }
  
  try {
    await initPhotosDirectory();
  } catch (error) {
    // In test mode, we can continue even if photos directory initialization fails
    if (process.env.TEST_MODE !== 'true') {
      throw error;
    }
    logger.warn({ error: error.message }, 'Photos directory initialization failed (continuing in test mode)');
  }
}

// Initialize and start server
async function start() {
  try {
    await initializeApp();
    
    // Start server
    app.listen(PORT, () => {
      logger.info({ port: PORT }, 'Server started successfully');
    });
    
  } catch (error) {
    logger.error({ error: error.message }, 'Failed to start server');
    process.exit(1);
  }
}

// Only start if this is the main module
if (import.meta.url === `file://${process.argv[1]}`) {
  start();
}
