/**
 * Generated by GitHub Copilot (GPT-5)
 * 
 * Database module for Google Maps Timeline Viewer
 * Manages SQLite database schema for places, photos, timeline files, and API usage tracking
 * 
 * Schema:
 * - places: Cached place details from Google Places API
 * - photos: Photo metadata and availability tracking
 * - timeline_files: Uploaded timeline JSON files
 * - api_usage: Daily API quota tracking
 */

import { mkdir } from 'fs/promises';
import { dirname, join } from 'path';
import pino from 'pino';

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  ...(process.env.NODE_ENV !== 'test' ? {
    transport: {
      target: 'pino-pretty',
      options: { colorize: true }
    }
  } : {})
});

const DATA_DIR = process.env.DATA_DIR || '/data';
const DB_PATH = join(DATA_DIR, 'cache.db');

let db = null;
let Database = null;
let dbLoadError = null;

// Try to load better-sqlite3, but don't fail at import time if it's not available
try {
  const mod = await import('better-sqlite3');
  Database = mod.default;
} catch (error) {
  dbLoadError = error;
}

/**
 * Initialize database connection and create tables if they don't exist
 */
export async function initDatabase() {
  try {
    // If Database failed to load and we're in test mode, just return without setting up DB
    if (!Database) {
      if (process.env.TEST_MODE === 'true') {
        logger.warn({ error: dbLoadError?.message }, 'better-sqlite3 not available in test mode, skipping database initialization');
        return null;
      }
      throw dbLoadError || new Error('Failed to load better-sqlite3');
    }

    // Ensure data directory exists
    await mkdir(dirname(DB_PATH), { recursive: true });
    
    db = new Database(DB_PATH);
    db.pragma('journal_mode = WAL');
    db.pragma('foreign_keys = ON');
    
    // Create tables
    createTables();
    
    logger.info({ dbPath: DB_PATH }, 'Database initialized successfully');
    return db;
  } catch (error) {
    logger.error({ error: error.message }, 'Failed to initialize database');
    if (process.env.TEST_MODE !== 'true') {
      throw error;
    }
    // In test mode, continue anyway
    return null;
  }
}

/**
 * Create database tables with proper schema
 */
function createTables() {
  // Places table: stores cached place details from Google Places API
  db.exec(`
    CREATE TABLE IF NOT EXISTS places (
      place_id TEXT PRIMARY KEY,
      display_name TEXT,
      formatted_address TEXT,
      location TEXT,
      svg_icon_mask_uri TEXT,
      icon_background_color TEXT,
      google_maps_uri TEXT,
      types TEXT,
      cached_at INTEGER NOT NULL,
      created_at INTEGER DEFAULT (strftime('%s', 'now'))
    )
  `);
  
  // Photos table: tracks photo availability and metadata
  db.exec(`
    CREATE TABLE IF NOT EXISTS photos (
      place_id TEXT PRIMARY KEY,
      has_webp INTEGER DEFAULT 0,
      has_jpeg INTEGER DEFAULT 0,
      sizes TEXT,
      cached_at INTEGER NOT NULL,
      created_at INTEGER DEFAULT (strftime('%s', 'now')),
      FOREIGN KEY (place_id) REFERENCES places(place_id) ON DELETE CASCADE
    )
  `);
  
  // Timeline files table: manages uploaded timeline JSON files
  db.exec(`
    CREATE TABLE IF NOT EXISTS timeline_files (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      filename TEXT NOT NULL UNIQUE,
      format TEXT NOT NULL,
      confidence INTEGER NOT NULL,
      uploaded_at INTEGER DEFAULT (strftime('%s', 'now')),
      is_active INTEGER DEFAULT 0
    )
  `);
  
  // API usage table: tracks daily Google Places API quota usage
  db.exec(`
    CREATE TABLE IF NOT EXISTS api_usage (
      date TEXT PRIMARY KEY,
      count INTEGER DEFAULT 0,
      quota_limit INTEGER NOT NULL,
      updated_at INTEGER DEFAULT (strftime('%s', 'now'))
    )
  `);
  
  // Create indexes for faster queries
  db.exec(`
    CREATE INDEX IF NOT EXISTS idx_places_cached_at ON places(cached_at);
    CREATE INDEX IF NOT EXISTS idx_photos_cached_at ON photos(cached_at);
    CREATE INDEX IF NOT EXISTS idx_timeline_active ON timeline_files(is_active);
    CREATE INDEX IF NOT EXISTS idx_api_usage_date ON api_usage(date);
  `);
  
  logger.info('Database tables created or verified');
}

/**
 * Get database instance
 */
export function getDatabase() {
  if (!db) {
    if (process.env.TEST_MODE === 'true') return null;
    throw new Error('Database not initialized. Call initDatabase() first.');
  }
  return db;
}

/**
 * Check if cached data is expired (older than TTL)
 */
export function isExpired(cachedAt) {
  const ttlDays = parseInt(process.env.CACHE_TTL_DAYS || '180');
  const ttlSeconds = ttlDays * 24 * 60 * 60;
  const now = Math.floor(Date.now() / 1000);
  return (now - cachedAt) > ttlSeconds;
}

/**
 * Get place details from cache
 */
export function getCachedPlace(placeId) {
  if (!db) return null;
  
  const stmt = db.prepare('SELECT * FROM places WHERE place_id = ?');
  const place = stmt.get(placeId);
  
  if (!place) return null;
  
  // Check if expired
  if (isExpired(place.cached_at)) {
    logger.debug({ placeId }, 'Cached place is expired');
    return { ...place, isExpired: true };
  }
  
  return { ...place, isExpired: false };
}

/**
 * Save place details to cache
 */
export function setCachedPlace(placeId, placeData) {
  if (!db) return false;
  
  const now = Math.floor(Date.now() / 1000);
  const stmt = db.prepare(`
    INSERT INTO places (
      place_id, display_name, formatted_address, location,
      svg_icon_mask_uri, icon_background_color, google_maps_uri,
      types, cached_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    ON CONFLICT(place_id) DO UPDATE SET
      display_name = excluded.display_name,
      formatted_address = excluded.formatted_address,
      location = excluded.location,
      svg_icon_mask_uri = excluded.svg_icon_mask_uri,
      icon_background_color = excluded.icon_background_color,
      google_maps_uri = excluded.google_maps_uri,
      types = excluded.types,
      cached_at = excluded.cached_at
  `);
  
  stmt.run(
    placeId,
    placeData.displayName || null,
    placeData.formattedAddress || null,
    placeData.location ? JSON.stringify(placeData.location) : null,
    placeData.svgIconMaskURI || null,
    placeData.iconBackgroundColor || null,
    placeData.googleMapsURI || null,
    placeData.types ? JSON.stringify(placeData.types) : null,
    now
  );
  
  logger.debug({ placeId }, 'Place cached successfully');
}

/**
 * Get photo metadata from cache
 */
export function getCachedPhoto(placeId) {
  const stmt = db.prepare('SELECT * FROM photos WHERE place_id = ?');
  const photo = stmt.get(placeId);
  
  if (!photo) return null;
  
  // Check if expired
  if (isExpired(photo.cached_at)) {
    logger.debug({ placeId }, 'Cached photo is expired');
    return { ...photo, isExpired: true };
  }
  
  return {
    ...photo,
    sizes: photo.sizes ? JSON.parse(photo.sizes) : [],
    isExpired: false
  };
}

/**
 * Save photo metadata to cache
 */
export function setCachedPhoto(placeId, hasWebP, hasJPEG, sizes) {
  const now = Math.floor(Date.now() / 1000);
  
  const stmt = db.prepare(`
    INSERT INTO photos (place_id, has_webp, has_jpeg, sizes, cached_at)
    VALUES (?, ?, ?, ?, ?)
    ON CONFLICT(place_id) DO UPDATE SET
      has_webp = excluded.has_webp,
      has_jpeg = excluded.has_jpeg,
      sizes = excluded.sizes,
      cached_at = excluded.cached_at
  `);
  
  stmt.run(
    placeId,
    hasWebP ? 1 : 0,
    hasJPEG ? 1 : 0,
    JSON.stringify(sizes),
    now
  );
  
  logger.debug({ placeId }, 'Photo metadata cached successfully');
}

/**
 * Get all timeline files
 */
export function getTimelineFiles() {
  if (!db) return [];
  const stmt = db.prepare('SELECT * FROM timeline_files ORDER BY uploaded_at DESC');
  return stmt.all();
}

/**
 * Get active timeline file
 */
export function getActiveTimeline() {
  if (!db) return null;
  const stmt = db.prepare('SELECT * FROM timeline_files WHERE is_active = 1');
  return stmt.get();
}

/**
 * Add timeline file
 */
export function addTimelineFile(filename, format, confidence) {
  const stmt = db.prepare(`
    INSERT INTO timeline_files (filename, format, confidence)
    VALUES (?, ?, ?)
  `);
  
  const result = stmt.run(filename, format, confidence);
  logger.info({ filename, format, confidence }, 'Timeline file added');
  return result.lastInsertRowid;
}

/**
 * Set active timeline file
 */
export function setActiveTimeline(id) {
  const transaction = db.transaction(() => {
    // Deactivate all
    db.prepare('UPDATE timeline_files SET is_active = 0').run();
    // Activate selected
    db.prepare('UPDATE timeline_files SET is_active = 1 WHERE id = ?').run(id);
  });
  
  transaction();
  logger.info({ id }, 'Active timeline updated');
}

/**
 * Get today's API usage
 */
export function getTodayApiUsage() {
  const today = new Date().toISOString().split('T')[0];
  const quotaLimit = parseInt(process.env.DAILY_API_QUOTA || '5000');
  
  if (!db) {
    return { date: today, count: 0, quota_limit: quotaLimit };
  }
  
  const stmt = db.prepare('SELECT * FROM api_usage WHERE date = ?');
  let usage = stmt.get(today);
  
  if (!usage) {
    // Initialize today's usage
    const insertStmt = db.prepare(`
      INSERT INTO api_usage (date, count, quota_limit)
      VALUES (?, 0, ?)
    `);
    insertStmt.run(today, quotaLimit);
    usage = { date: today, count: 0, quota_limit: quotaLimit };
  }
  
  return usage;
}

/**
 * Increment API usage counter
 */
export function incrementApiUsage() {
  const today = new Date().toISOString().split('T')[0];
  const quotaLimit = parseInt(process.env.DAILY_API_QUOTA || '5000');
  
  const stmt = db.prepare(`
    INSERT INTO api_usage (date, count, quota_limit)
    VALUES (?, 1, ?)
    ON CONFLICT(date) DO UPDATE SET
      count = count + 1,
      updated_at = strftime('%s', 'now')
  `);
  
  stmt.run(today, quotaLimit);
  
  const usage = getTodayApiUsage();
  logger.debug({ usage }, 'API usage incremented');
  
  return usage;
}

/**
 * Check if API quota is exceeded
 */
export function isQuotaExceeded() {
  const usage = getTodayApiUsage();
  return usage.count >= usage.quota_limit;
}

/**
 * Get all place IDs from cache
 */
export function getAllCachedPlaceIds() {
  const stmt = db.prepare('SELECT place_id FROM places');
  return stmt.all().map(row => row.place_id);
}

/**
 * Delete expired cache entries
 */
export function deleteExpiredCache() {
  const ttlDays = parseInt(process.env.CACHE_TTL_DAYS || '180');
  const ttlSeconds = ttlDays * 24 * 60 * 60;
  const cutoff = Math.floor(Date.now() / 1000) - ttlSeconds;
  
  const deletePlaces = db.prepare('DELETE FROM places WHERE cached_at < ?');
  const deletePhotos = db.prepare('DELETE FROM photos WHERE cached_at < ?');
  
  const placesResult = deletePlaces.run(cutoff);
  const photosResult = deletePhotos.run(cutoff);
  
  logger.info(
    { placesDeleted: placesResult.changes, photosDeleted: photosResult.changes },
    'Expired cache entries deleted'
  );
  
  return {
    placesDeleted: placesResult.changes,
    photosDeleted: photosResult.changes
  };
}

/**
 * Close database connection
 */
export function closeDatabase() {
  if (db) {
    db.close();
    db = null;
    logger.info('Database connection closed');
  }
}
