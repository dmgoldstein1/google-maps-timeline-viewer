/**
 * Generated by GitHub Copilot (GPT-5)
 * 
 * Format detection module for Google Maps Timeline files
 * Auto-detects timeline file format and provides confidence score
 * 
 * Supported formats:
 * - iOS Timeline.json (on-device export from iOS Google Maps)
 * - Google Takeout Semantic Location History
 * - Semantic Segments format
 */

import pino from 'pino';

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: {
    target: 'pino-pretty',
    options: { colorize: true }
  }
});

/**
 * Detect timeline file format from JSON data
 * 
 * @param {Object|Array} data - Parsed JSON data
 * @returns {Object} { format: string, confidence: number (0-100) }
 */
export function detectFormat(data) {
  try {
    // Check for iOS Timeline format (array of objects with visit/activity)
    if (Array.isArray(data)) {
      return detectiOSFormat(data);
    }
    
    // Check for object-based formats
    if (typeof data === 'object' && data !== null) {
      // Google Takeout Semantic Location History
      if (data.timelineObjects) {
        return detectGoogleTakeoutFormat(data);
      }
      
      // Semantic Segments format
      if (data.semanticSegments) {
        return detectSemanticSegmentsFormat(data);
      }
    }
    
    // Unknown format
    return {
      format: 'unknown',
      confidence: 0,
      message: 'Unrecognized timeline data structure'
    };
    
  } catch (error) {
    logger.error({ error: error.message }, 'Error detecting format');
    return {
      format: 'error',
      confidence: 0,
      message: error.message
    };
  }
}

/**
 * Detect iOS Timeline format
 */
function detectiOSFormat(data) {
  if (data.length === 0) {
    return {
      format: 'ios',
      confidence: 50,
      message: 'Empty array - possibly iOS format'
    };
  }
  
  let visitCount = 0;
  let activityCount = 0;
  let timelinePathCount = 0;
  let hasGeoFormat = false;
  let hasPlaceID = false;
  
  // Sample first 10 items
  const sample = data.slice(0, Math.min(10, data.length));
  
  for (const item of sample) {
    if (item.visit) {
      visitCount++;
      if (item.visit.topCandidate?.placeID) hasPlaceID = true;
      if (item.visit.topCandidate?.placeLocation?.startsWith('geo:')) hasGeoFormat = true;
    }
    if (item.activity) {
      activityCount++;
      if (item.activity.start?.startsWith('geo:')) hasGeoFormat = true;
    }
    if (item.timelinePath) {
      timelinePathCount++;
    }
  }
  
  // Calculate confidence
  let confidence = 0;
  if (visitCount > 0 || activityCount > 0) confidence += 40;
  if (hasGeoFormat) confidence += 30;
  if (hasPlaceID) confidence += 20;
  if (timelinePathCount > 0) confidence += 10;
  
  return {
    format: 'ios',
    confidence: Math.min(100, confidence),
    message: `iOS Timeline detected: ${visitCount} visits, ${activityCount} activities`
  };
}

/**
 * Detect Google Takeout Semantic Location History format
 */
function detectGoogleTakeoutFormat(data) {
  if (!Array.isArray(data.timelineObjects)) {
    return {
      format: 'google-takeout',
      confidence: 30,
      message: 'Has timelineObjects but not an array'
    };
  }
  
  if (data.timelineObjects.length === 0) {
    return {
      format: 'google-takeout',
      confidence: 50,
      message: 'Empty timelineObjects array'
    };
  }
  
  let placeVisitCount = 0;
  let activitySegmentCount = 0;
  let hasE7Coords = false;
  let hasPlaceId = false;
  
  // Sample first 10 items
  const sample = data.timelineObjects.slice(0, Math.min(10, data.timelineObjects.length));
  
  for (const item of sample) {
    if (item.placeVisit) {
      placeVisitCount++;
      if (item.placeVisit.location?.placeId) hasPlaceId = true;
      if (item.placeVisit.location?.latitudeE7 !== undefined) hasE7Coords = true;
    }
    if (item.activitySegment) {
      activitySegmentCount++;
      if (item.activitySegment.startLocation?.latitudeE7 !== undefined) hasE7Coords = true;
    }
  }
  
  // Calculate confidence
  let confidence = 0;
  if (placeVisitCount > 0 || activitySegmentCount > 0) confidence += 40;
  if (hasE7Coords) confidence += 30;
  if (hasPlaceId) confidence += 20;
  if (data.timelineObjects.length > 0) confidence += 10;
  
  return {
    format: 'google-takeout',
    confidence: Math.min(100, confidence),
    message: `Google Takeout detected: ${placeVisitCount} place visits, ${activitySegmentCount} activity segments`
  };
}

/**
 * Detect Semantic Segments format
 */
function detectSemanticSegmentsFormat(data) {
  if (!Array.isArray(data.semanticSegments)) {
    return {
      format: 'semantic-segments',
      confidence: 30,
      message: 'Has semanticSegments but not an array'
    };
  }
  
  if (data.semanticSegments.length === 0) {
    return {
      format: 'semantic-segments',
      confidence: 50,
      message: 'Empty semanticSegments array'
    };
  }
  
  let visitCount = 0;
  let activityCount = 0;
  let hasTimelinePath = false;
  
  // Sample first 10 items
  const sample = data.semanticSegments.slice(0, Math.min(10, data.semanticSegments.length));
  
  for (const item of sample) {
    if (item.visit) visitCount++;
    if (item.activity) activityCount++;
    if (item.timelinePath) hasTimelinePath = true;
  }
  
  // Calculate confidence
  let confidence = 0;
  if (visitCount > 0 || activityCount > 0) confidence += 40;
  if (hasTimelinePath) confidence += 30;
  if (data.semanticSegments.length > 0) confidence += 30;
  
  return {
    format: 'semantic-segments',
    confidence: Math.min(100, confidence),
    message: `Semantic Segments detected: ${visitCount} visits, ${activityCount} activities`
  };
}

/**
 * Extract place IDs from timeline data based on format
 * 
 * @param {Object|Array} data - Parsed timeline data
 * @param {string} format - Detected format
 * @returns {Array<string>} Array of unique place IDs
 */
export function extractPlaceIds(data, format) {
  const placeIds = new Set();
  
  try {
    switch (format) {
      case 'ios':
        extractiOSPlaceIds(data, placeIds);
        break;
      case 'google-takeout':
        extractGoogleTakeoutPlaceIds(data, placeIds);
        break;
      case 'semantic-segments':
        extractSemanticSegmentsPlaceIds(data, placeIds);
        break;
      default:
        logger.warn({ format }, 'Unknown format for place ID extraction');
    }
  } catch (error) {
    logger.error({ error: error.message, format }, 'Error extracting place IDs');
  }
  
  return Array.from(placeIds);
}

/**
 * Extract place IDs from iOS format
 */
function extractiOSPlaceIds(data, placeIds) {
  for (const item of data) {
    if (item.visit?.topCandidate?.placeID) {
      placeIds.add(item.visit.topCandidate.placeID);
    }
  }
}

/**
 * Extract place IDs from Google Takeout format
 */
function extractGoogleTakeoutPlaceIds(data, placeIds) {
  if (!data.timelineObjects) return;
  
  for (const item of data.timelineObjects) {
    if (item.placeVisit?.location?.placeId) {
      placeIds.add(item.placeVisit.location.placeId);
    }
  }
}

/**
 * Extract place IDs from Semantic Segments format
 */
function extractSemanticSegmentsPlaceIds(data, placeIds) {
  if (!data.semanticSegments) return;
  
  for (const item of data.semanticSegments) {
    if (item.visit?.topCandidate?.placeID) {
      placeIds.add(item.visit.topCandidate.placeID);
    }
  }
}

/**
 * Validate timeline data structure
 */
export function validateTimelineData(data) {
  if (!data) {
    return { valid: false, message: 'No data provided' };
  }
  
  const detection = detectFormat(data);
  
  if (detection.confidence < 50) {
    return {
      valid: false,
      message: `Low confidence (${detection.confidence}%) in format detection: ${detection.message}`
    };
  }
  
  return {
    valid: true,
    format: detection.format,
    confidence: detection.confidence,
    message: detection.message
  };
}
