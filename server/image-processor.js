/**
 * Generated by GitHub Copilot (GPT-5)
 * 
 * Image processing module for Google Maps Timeline Viewer
 * Handles downloading and resizing place photos from Google Places API
 * Generates multiple sizes in both WebP and JPEG formats for responsive images
 * 
 * Features:
 * - Downloads photos from Google Places API
 * - Generates multiple resolutions: 150px, 400px, 800px, 1200px
 * - Outputs both WebP (better compression) and JPEG (compatibility)
 * - Maintains aspect ratio
 * - Stores in organized directory structure
 */

import sharp from 'sharp';
import { mkdir, unlink, access } from 'fs/promises';
import { join } from 'path';
import { constants } from 'fs';
import pino from 'pino';

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: {
    target: 'pino-pretty',
    options: { colorize: true }
  }
});

const DATA_DIR = process.env.DATA_DIR || '/data';
const PHOTOS_DIR = join(DATA_DIR, 'photos');

// Photo sizes to generate (in pixels, width)
const PHOTO_SIZES = process.env.PHOTO_SIZES
  ? process.env.PHOTO_SIZES.split(',').map(s => parseInt(s.trim()))
  : [150, 400, 800, 1200];

// Quality settings
const WEBP_QUALITY = parseInt(process.env.WEBP_QUALITY || '85');
const JPEG_QUALITY = parseInt(process.env.JPEG_QUALITY || '80');

/**
 * Initialize photos directory
 */
export async function initPhotosDirectory() {
  try {
    await mkdir(PHOTOS_DIR, { recursive: true });
    logger.info({ photosDir: PHOTOS_DIR }, 'Photos directory initialized');
  } catch (error) {
    logger.error({ error: error.message }, 'Failed to initialize photos directory');
    throw error;
  }
}

/**
 * Get directory path for a place's photos
 */
function getPlacePhotoDir(placeId) {
  return join(PHOTOS_DIR, placeId);
}

/**
 * Get file path for a specific photo size and format
 */
function getPhotoPath(placeId, size, format) {
  return join(PHOTOS_DIR, placeId, `${size}.${format}`);
}

/**
 * Check if photo exists
 */
export async function photoExists(placeId, size, format) {
  const path = getPhotoPath(placeId, size, format);
  try {
    await access(path, constants.F_OK);
    return true;
  } catch {
    return false;
  }
}

/**
 * Process and save photo in multiple formats and sizes
 * 
 * @param {Buffer} imageBuffer - Raw image data from Google Places API
 * @param {string} placeId - Place ID for organizing files
 * @returns {Object} { success: boolean, sizes: number[], formats: string[] }
 */
export async function processPhoto(imageBuffer, placeId) {
  try {
    // Create directory for this place's photos
    const placeDir = getPlacePhotoDir(placeId);
    await mkdir(placeDir, { recursive: true });
    
    const processedSizes = [];
    const formats = ['webp', 'jpeg'];
    
    // Process each size
    for (const size of PHOTO_SIZES) {
      try {
        // Load image with sharp
        const image = sharp(imageBuffer);
        const metadata = await image.metadata();
        
        // Skip if original is smaller than target size
        if (metadata.width < size) {
          logger.debug({ placeId, size, originalWidth: metadata.width }, 'Skipping size larger than original');
          continue;
        }
        
        // Resize maintaining aspect ratio
        const resized = image.resize(size, null, {
          fit: 'inside',
          withoutEnlargement: true
        });
        
        // Save WebP version
        await resized
          .clone()
          .webp({ quality: WEBP_QUALITY })
          .toFile(getPhotoPath(placeId, size, 'webp'));
        
        // Save JPEG version
        await resized
          .clone()
          .jpeg({ quality: JPEG_QUALITY })
          .toFile(getPhotoPath(placeId, size, 'jpeg'));
        
        processedSizes.push(size);
        
        logger.debug({ placeId, size }, 'Photo size processed');
      } catch (error) {
        logger.error({ placeId, size, error: error.message }, 'Failed to process photo size');
      }
    }
    
    if (processedSizes.length === 0) {
      logger.warn({ placeId }, 'No photo sizes were processed');
      return {
        success: false,
        sizes: [],
        formats: []
      };
    }
    
    logger.info({ placeId, sizes: processedSizes }, 'Photo processed successfully');
    
    return {
      success: true,
      sizes: processedSizes,
      formats: formats,
      hasWebP: true,
      hasJPEG: true
    };
    
  } catch (error) {
    logger.error({ placeId, error: error.message }, 'Failed to process photo');
    return {
      success: false,
      sizes: [],
      formats: [],
      error: error.message
    };
  }
}

/**
 * Delete all photos for a place (used when re-fetching)
 * 
 * @param {string} placeId - Place ID
 * @returns {boolean} Success status
 */
export async function deletePlacePhotos(placeId) {
  try {
    const placeDir = getPlacePhotoDir(placeId);
    
    // Delete all sizes and formats
    for (const size of PHOTO_SIZES) {
      for (const format of ['webp', 'jpeg']) {
        const photoPath = getPhotoPath(placeId, size, format);
        try {
          await unlink(photoPath);
        } catch (error) {
          // File might not exist, ignore
        }
      }
    }
    
    // Try to remove directory (will only succeed if empty)
    try {
      await unlink(placeDir);
    } catch {
      // Directory might not be empty or not exist, ignore
    }
    
    logger.debug({ placeId }, 'Place photos deleted');
    return true;
    
  } catch (error) {
    logger.error({ placeId, error: error.message }, 'Failed to delete place photos');
    return false;
  }
}

/**
 * Get available sizes for a place's photos
 * 
 * @param {string} placeId - Place ID
 * @returns {Array<number>} Available sizes
 */
export async function getAvailableSizes(placeId) {
  const availableSizes = [];
  
  for (const size of PHOTO_SIZES) {
    // Check if at least one format exists
    const hasWebP = await photoExists(placeId, size, 'webp');
    const hasJPEG = await photoExists(placeId, size, 'jpeg');
    
    if (hasWebP || hasJPEG) {
      availableSizes.push(size);
    }
  }
  
  return availableSizes;
}

/**
 * Get photo statistics
 * 
 * @returns {Object} Statistics about stored photos
 */
export async function getPhotoStats() {
  try {
    const { readdir, stat } = await import('fs/promises');
    
    let totalFiles = 0;
    let totalSize = 0;
    let placeCount = 0;
    
    const places = await readdir(PHOTOS_DIR);
    
    for (const place of places) {
      const placeDir = join(PHOTOS_DIR, place);
      const placeStat = await stat(placeDir);
      
      if (placeStat.isDirectory()) {
        placeCount++;
        const files = await readdir(placeDir);
        
        for (const file of files) {
          const filePath = join(placeDir, file);
          const fileStat = await stat(filePath);
          totalFiles++;
          totalSize += fileStat.size;
        }
      }
    }
    
    return {
      placeCount,
      totalFiles,
      totalSizeMB: (totalSize / (1024 * 1024)).toFixed(2),
      averageFileSizeKB: totalFiles > 0 ? ((totalSize / totalFiles) / 1024).toFixed(2) : 0
    };
    
  } catch (error) {
    logger.error({ error: error.message }, 'Failed to get photo stats');
    return {
      placeCount: 0,
      totalFiles: 0,
      totalSizeMB: 0,
      averageFileSizeKB: 0
    };
  }
}

/**
 * Validate image buffer
 * 
 * @param {Buffer} buffer - Image buffer to validate
 * @returns {Promise<Object>} { valid: boolean, format: string, width: number, height: number }
 */
export async function validateImage(buffer) {
  try {
    const image = sharp(buffer);
    const metadata = await image.metadata();
    
    return {
      valid: true,
      format: metadata.format,
      width: metadata.width,
      height: metadata.height,
      size: buffer.length
    };
  } catch (error) {
    return {
      valid: false,
      error: error.message
    };
  }
}
